



一、协议栈通过TCP协议收发数据的操作

二、TCP和UDP的差别





一、协议栈通过TCP协议收发数据的操作

1.创建套接字

2.客户端套接字与服务器套接字相连

3.收发数据，协议栈会与网卡配合，将数据切成小块并封装成网络包，再将网络包转换成电信号或光信号发送

4.断开连接并删除套接字，断开操作的本质是当消息收发完成后客户端和服务器相互确认的过程。



![图1](https://github.com/rjwx60/Reading-notes/blob/master/%E3%80%8AHow%20Networks%20Work%E3%80%8B-%20%E6%88%B7%E6%A0%B9%E5%8B%A4/imgs/2-01.png)

浏览器、邮件等一般应用程序收发数据时用TCP

DNS查询等收发较短控制数据时用UDP



IP中的ICMP协议用于告知网络包传送过程中产生的错误和各种控制信息

IP中的ARP协议用于根据IP地址查询相应的以太网MAC地址



网卡驱动程序负责控制网卡硬件

网卡负责完成实际的收发操作







👇👇👇TCP头部

👇👇👇TCP头部

👇👇👇TCP头部



——套接字只是一个概念，并不存在实体

协议栈内部有一块用于存放控制信息的内存空间，记录了用于控制数据收发操作的控制信息，比如通信对象的IP地址、端口号、通信操作的进行状态等



——或者可以说，存放控制信息的内存空间就是套接字的实体

——协议栈在执行操作的时需要参阅这些控制信息。

——套接字中记录了用于控制通信操作的各种控制信息，协议栈需要根据这些信息判断下一步的行动



用netstat显示套接字内容，每一行相当于一个套接字

![屏幕快照 2018-07-28 上午9.55.27.png](/Users/rjwx60/Library/Application Support/typora-user-images/1EB47020-6B40-4F58-98D3-FA171FB4E48A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8A%E5%8D%889.55.27.png)





——调用socket创建套接字

第一步是利用内存管理模块分配一个套接字所需的内存空间

第二步是写入初始状态的控制信息

第三步是将这个套接字的描述符告知应用程序。



注意！套接字刚创建完成时，并没有任何有用的数据，浏览器可以根据网址查询IP，但这也只是浏览器等程序知道，在创建套接字的时候这些信息并没有传递给协议栈

![屏幕快照 2018-07-28 上午10.04.07.png](/Users/rjwx60/Library/Application Support/typora-user-images/1EB47020-6B40-4F58-98D3-FA171FB4E48A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8A%E5%8D%8810.04.07.png)





——连接服务器

连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作。



——连接操作：

1.需要将自身拥有的服务器IP地址和端口号等信息告知协议栈 

2.需要开辟用于存放临时收发数据的内存空间 

3.传达开始通信的请求。



——控制信息有两类

一类是客户端和服务器相互联络时交换的控制信息，这种在连接、收发、断开都需要用到

二类是保存在套接字中的用来控制协议栈操作的信息。



——控制信息位于网络包的头部，以太网、IP协议也有自己的控制信息。

![屏幕快照 2018-07-28 上午10.17.24.png](/Users/rjwx60/Library/Application Support/typora-user-images/1EB47020-6B40-4F58-98D3-FA171FB4E48A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-28%20%E4%B8%8A%E5%8D%8810.17.24.png)











——连接操作的实际过程

首先，客户端先创建一个，包含表示开始数据收发操作的控制信息的，头部。

——头部包含很多字段，通过TCP头部中的发送方和接收方的端口可以找到要连接的套接字



然后，将头部中的控制位的SYN比特设置为1，表示“连接”。



接着，TCP模块将信息，传递给IP模块，并委托它进行发送。



紧接着，服务器收到后，从等待连接状态变为正在连接状态



同样，服务器端需要在TCP头部中设置发送方和接收方的端口号，设置SYN为1，表示“连接”，并将ACK设为1，表示已经收到相应的网络包。



然后，客户端收到后，也需要将ACK设置为1，返回给服务器。



最后，服务器收到后，连接操作才算全部完成。



此后，套接字已经进入随时可以收发数据的状态了。





——TCP头部中的部分字段

——MTU和MSS

应用程序交给协议栈发送的数据长度是由应用程序本身决定的，不同的应用程序交予的数据的长度不尽相同，所以要对发送的数据做一个限制。



MTU 是每个网络包能容纳的数据长度

MSS 除去头部后，一个网络包所能容纳的TCP数据的最大长度

![屏幕快照 2018-07-29 上午8.39.52.png](/Users/rjwx60/Library/Application Support/typora-user-images/1EB47020-6B40-4F58-98D3-FA171FB4E48A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8A%E5%8D%888.39.52.png)



——序号和原本数据的长度

将长包拆分，最后组装需要序号来判定原本的位置，序号初始值是随机数计算得出的

如果对方没有返回某些包对应的ACK号，则重发，如果重发数次仍无效，则强制结束通信，向上层报错



——通过TCP头部中的序号和ACK号可以确认接收方是否收到了网络包

![屏幕快照 2018-07-29 上午8.40.19.png](/Users/rjwx60/Library/Application Support/typora-user-images/1EB47020-6B40-4F58-98D3-FA171FB4E48A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8A%E5%8D%888.40.19.png)









——根据网络包平均往返时间调整ACK号等待时间

因为当网络传输频繁时会发生拥塞，ACK号的返回会变慢，此时需要设置长一点的等待时间，因为重传没必要且会加重拥塞情况，但等待时间越长，延迟越高，也会导致网速变慢



——所以，TCP采用了动态调整等待时间的方法

——此外，等待ACK号返回的这段时间不能浪费，所以采用了滑动窗口的方式，管理数据的发送和ACK号的操作



但问题又来了，滑动窗口是连续发送一系列的包，有可能出现发送包的频率超过接收方的处理能力

这是因为接收方接收到数据后，会先放到缓冲区，然后计算ACK号，然后拼接还原给应用程序，如果处理缓冲区数据的速度跟不上接收到的速度，就会发生溢出，也就是接收到后面的包，相当于丢包



——所以，接收方要告知发送方自身最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制，这是滑动窗口方式的基本思路。

——接收方所能接收的最大数据量称为窗口大小

![屏幕快照 2018-07-29 下午10.52.37.png](/Users/rjwx60/Library/Application Support/typora-user-images/1EB47020-6B40-4F58-98D3-FA171FB4E48A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8B%E5%8D%8810.52.37.png)





——ACK号和更新后的窗口大小数值合并返回能减少包的数量

——ACK号的发送是在，接收方收到数据时，如果确认内容没有问题，就向发送方返回ACK号告知。

——更新窗口大小的时机，是在接收方从缓冲区中取出数据传递给应用程序的时候。





——协议栈接收数据的具体操作过程

![屏幕快照 2018-07-29 下午10.52.10.png](/Users/rjwx60/Library/Application Support/typora-user-images/1EB47020-6B40-4F58-98D3-FA171FB4E48A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8B%E5%8D%8810.52.10.png)





——断开连接，具体来说就是将控制位中的FIN比特设为1





——TCP协议手法应用程序数据的操作小结：P93 - 95      Nice!!!

![屏幕快照 2018-07-29 下午10.52.21.png](/Users/rjwx60/Library/Application Support/typora-user-images/1EB47020-6B40-4F58-98D3-FA171FB4E48A/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-29%20%E4%B8%8B%E5%8D%8810.52.21.png)









——包的基本结构和知识

![WechatIMG368.jpeg](/Users/rjwx60/Library/Application Support/typora-user-images/1EB47020-6B40-4F58-98D3-FA171FB4E48A/WechatIMG368.jpeg)

——路由器是根据目标地址判断下一个路由器的位置，是按照IP规则传输包的设备，集线器中有用于以太网协议的表

——集线器在子网中将网络包传输到下一个路由，是按照以太网规则传输包的设备，路由器中有用于IP协议的表



——只有在经过路由器时，MAC头部才会更新，集线器的职能更多体现在转发上。

![WechatIMG369.jpeg](/Users/rjwx60/Library/Application Support/typora-user-images/1EB47020-6B40-4F58-98D3-FA171FB4E48A/WechatIMG369.jpeg)



——包收发操作的流程 P99-102

——IP模块负责添加MAC头部和IP头部

前者包含通过以太网的局域网将包传输至最近的路由器所需的控制信息

后者包含IP协议规定的、根据IP地址将包发往目的地所需的控制信息





TCP和UDP的差别

在DNS查询、交换控制信息的操作等基本都可在一个包的大小范围内解决的场景，可用UDP来代替繁琐的TCP。

在发送音频和视频数据等重发无意义、须要在规定时间内送达的场景，可用UDP来代替。



UDP没有TCP的接收确认、窗口机制，不需要交换控制信息、不需要建立和断开连接。



发送UDP，只需在数据前加上UDP头部，然后交给IP即可。

接收UDP，只需根据IP头部中的接收方和发送方IP地址，UDP头部中的接收方和发送方端口号，找到相应的套接字，交与程序即可











👆👆👆是TCP头部，👇👇👇是IP头部和MAC头部

👆👆👆是TCP头部，👇👇👇是IP头部和MAC头部

👆👆👆是TCP头部，👇👇👇是IP头部和MAC头部



——IP头部

IP地址长度为32比特

IP头部包含的通信对象的IP地址，是由TCP模块告知的，TCP又是在执行连接操作时从应用程序那获得到的。

IP地址实际上并不是分配给计算机的，而是分配给网卡的

路由器使用IP表/路由表来判断下一个路由的位置（具体方法是来者IP和本地IP一致就不转发，不一致则转发至别的入口）

IP头部中的协议号，表示包的内容来自哪个模块，如06表示TCP模块，17表示UDP模块



——MAC头部

MAC地址长度为48比特

MAC头部包含了接收方和发送方的MAC地址等信息

MAC地址是在网卡生产时写入ROM里的



在发往给对方时，需要知道对方的MAC地址，但包还未发送，所以就需要像通过域名查询IP那样，这里通过IP查询MAC地址

利用ARP查询MAC地址

ARP是利用广播的方法，将包发给连接在同一以太网中的所有设备。

ARP查询的结果会放到一块叫ARP缓存的内存空间中待日后使用，这里的内容过一段时间后会被删除。











——以太网基本

古时，在网络中任一一台设备发送的信号所有设备都能接收得到，只不过同接收者匹配的就接收，否则就丢弃

后来，信号只会根据MAC地址流到指定的设备



以太网的3个性质：

将包发送到MAC头部的接收方MAC地址代表的目的地

用发送方MAC地址识别发送方

用以太类型识别包的内容



——真正的数据发送过程是网卡将数字信号转换成电或光信号

1.网卡驱动从IP模块获取包，放入网卡缓存，向MAC模块发送发送包的指令

2.MAC模块工作，从缓冲区中取出包，在开头，加上报头和起始帧分界符，在末尾，加上FCS（帧校验序列）

3.报头的作用是确定包的读取时机，测量时钟信号的特殊信号

4.为了区分每个比特的间隔，除了发送数据信号，还发送时钟信号

5.为了因传输产生的时间差而导致的偏移，采用将数据信号和时钟信号叠加的方法

6末尾的FCS是用来检查包传输过程中因噪声导致的波形紊乱的问题，同磁盘的CRC错误校验码是同一种东西。







——发送信号的操作分成两种，一种是采用集线器的半双工模式，一种是采用交换机的全双工模式

采用半双工有很多问题，如信号碰撞，为了解决这些问题又有很多应对措施，而全双工就不用考虑这么多复杂的问题



——网卡的MAC模块生成通用信号，然后通过PHY(MAU)模块转换成可在网线中传输的格式，并通过网线发送出去。

以太网规格中对不同的网线类型和速率以及其对应的信号格式进行了规定，但MAC模块不会关心这些区别，而是将可转换为任意格式的通用信号发送给PHY(MAU)模块，然后这个模块再将其转换为可在网线上传输的格式。



——可以认为PHY(MAU)模块的功能就是对MAC模块产生的信号进行格式转换







——接收网络包的操作过程 P123起



—>接收信号



—>PHY(MAU)模块将信号转换成通用格式并发送给MAC模块



—>MAC模块通过报头的波形同步时钟，遇到起始帧分界符时将后面的信号转换成为数字信息，存放到缓冲区中，到信号末尾时候，检查FCS，如果利用包头到结尾的所有比特计算出的FCS跟末尾的FCS不一致，则弃包；如果没问题，检查MAC地址是否与本机一致，一致的话，通知计算机



—>通知计算机的操作使用中断的机制。

首先，网卡向扩展总线中的中断信号线发送信号，该线通过计算机中的中断控制器连接到CPU，然后CPU暂时挂起正在处理的任务，切换到操作系统的中断处理程序，程序调用网卡驱动，控制网卡执行接收操作



—>网卡从缓冲区中取出包，交给TCP/IP协议



—>IP模块首先检查IP头部，若格式没问题，就查看接收方的IP地址，没问题就接收这个包，有问题就通过ICMP消息将错误告知发送方，接收以后，IP模块会将包暂存，等待IP头部中具有相同ID的包全部到达，然后根据IP头部中的，表示当前分片在整个包中所处位置的分片偏移量字段，来讲分片还原成原始包，这一操作称为分片重组。重组完毕后，交给TCP模块



—>TCP模块会根据：IP头部中的接收方IP地址，IP头部中的发送方IP地址，以及TCP头部中的接收方和发送方端口号来，查找对应的套接字，然后根据套接字中的通信状态来执行相应的操作：

若是应用程序数据，返回确认接收包，放入缓存，等待读取

若是建立或断开连接的控制包，返回相应的控制包，告知应用程序建立和断开连接的操作状态



