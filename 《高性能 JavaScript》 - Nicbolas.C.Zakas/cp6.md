
### 浏览器UI线程：
UI线程 基于一个队列系统，用于执行Js和更新用户界面  
大多数浏览器的 UI进程 都是单线程，每一时刻只能执行一种操作,如：  

——>  点击按钮，触发 UI线程 创建2个任务并添加到队列中存储   
——>  线程空闲，提取第一个任务（更新按钮 UI任务）到线程执行  
——>  线程空闲，提取第二个任务（执行调用的 JS任务）到线程执行  

### 阻止JS阻塞界面的两种方式：
实际中，大多数浏览器在 JS 运行时，会停止把新任务加入到 UI 线程队列中  

#### 被动方式 - 浏览器限制
浏览器限制是有必要的，确保恶意代码不能永不停止密集操作锁死用户浏览器  

##### 限制策略大致分为：
—调用栈大小限制  
—长时间运行脚本限制   

##### 不同浏览器检测长时间运行脚本的方法不同
或记录自脚本开始执行以来执行的语句数量  
或记录脚本执行总时长  
或崩溃检测系统  
或直接人为限制每一 JS操作耗时在 50( 100 )毫秒以内  

#### 主动方式 - UI线程之内 - 定时器
￼<!-- ![图1](https://github.com/rjwx60/Reading-notes/blob/master/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD%20JavaScript%E3%80%8B%20-%20Nicbolas.C.Zakas/imgs/1-01.png)   -->
<img src="https://github.com/rjwx60/Reading-notes/raw/master/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD%20JavaScript%E3%80%8B%20-%20Nicbolas.C.Zakas/imgs/6-01.png" alt="图1" width="300px">

上图执行到 setTimeout，等待100ms后加入队列中  
—若 function 已经执行完，总的执行时间为 n，则 定时器会在 n + 100后被调用   
—若 function 执行时间 > 100，则当其执行完成后，定时器会立即执行  

##### 定时器是长时间运行JS的理想跨浏览器解决方案
从一个任务切换到下一个任务，创建定时器会造成UI线程暂停  
故定时器代码会重置所有相关的浏览器限制  

##### 定时器可用于处理大数组或分割需时长的任务
使用多个重复定时器会有性能问题  
所有定时器都在争夺运行时间  

#### 主动方式 - UI线程之外 - WebWorker
WebWorker 自身有全局运行环境，无法在 Js中创建，只能创建独立的 Js文件  
WebWorker 没有绑定 UI线程，不能访问浏览器资源  

WebWorker 适用加载外部文件、处理纯数据、处理与浏览器 UI无关 的长时间运行脚本  
WebWorker 适用编码解码、复杂数学运算（图像或视频处理）、大数组排序  