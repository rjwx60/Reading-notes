## 数据存储位置影响代码执行时的数据检索速度

数据存储的方式：字面量、变量、数组项、对象成员   
访问速度对比：字面量、局部变量 **>** 数组项、对象成员    


### 一、将常用跨作用域引用值保存在局部变量中

#### 作用域链：
Js对象有：可编程访问的属性 和 仅供Js引擎访问的内部属性，如: `[[Scope]]`  
作用域链：即 `[[Scope]]` 中包含的，函数被创建的作用域中的对象的集合  
如: 全局作用域就会有：this、window、document等对象  
如: 函数被创建后，这个函数的作用域链会被，创建此函数的作用域中可访问的数据对象填充

#### 执行环境**/**上下文：
调用函数时会创建一个叫执行环境的内部对象  
其定义函数执行时的环境，并在函数执行完毕时销毁    

其有自己的作用域链，在被创建时，它的作用域链被初始化为：  
当前运行函数的 `[[Scope]]` 属性中的对象集合，然后值按照其在函数中出现的顺序，被复制到执行环境的 `[[Scope]]` 中  
当复制完成，即创建了一个活动对象，此后它被推入作用域链的最前端    

注意：Js对象内部属性中包含，执行环境 和 普通的 `[[Scope]]`  
注意：执行环境在调用时创建：有自己的 `[[Scope]]` 属性，普通的 `[[Scope]]` 在创建时创建  
注意：执行环境包含：普通 `[[Scope]]` 的值 + 活动对象，即对象外围作用域的对象集合 + 对象内部的值  
注意：普通的 `[[Scope]]`：包含的是，对象被创建的作用域中的对象的集合  

#### 标识符的解析过程：
过程搜索执行环境的作用域链，从头部开始搜索，查找同名的标识符  
标识符所处位置越深，读写速度越慢，局部变量位于作用域链的起始位置，全局变量位于作用域链的末端    


### 二、避免使用**with**、**eval**、**catch**()
#### 原因一：
使用它们时，新的变量对象被创建，并被推入执行环境的作用域链前端，先前的活动对象位移至第二位，局部变量的访问代价变高，性能开销变大  
注意：若没有局部变量的访问操作，作用域链的临时改变不会影响代码性能  
如：`catch(ex){ console.log( ex ) }`

#### 原因二：
原本Js引擎有针对传统作用域链查找的优化（即避开，用别的方法取代 传统的标识符索引查找）  
但当涉及动态作用域时，这种优化方式失效了    


### 三、闭包存在性能问题
闭包的 `[[Scope]]` 属性包含:   
与执行环境作用域链相同的对象引用，这阻止了活动对象在函数调用完后的及时销毁，增加了内存开销    

闭包的执行环境的 `[[Scope]]` 属性包含：  
自身`[[Scope]]`属性中所引用的作用域链对象，外加自己创建的活动对象    

### 四、将常用对象成员保存在局部变量中
嵌套层级越深，性能影响越大  

